#include <iostream>

int main() {
  float V[4];     //4х Компонентный начальный вектор
  float M[4][4];  //Начальная Матрица М 4х4
  float R[4] = {0, 0, 0, 0};     //Конечный компонентный вектор R
  //Заполнение вектора V
  std::cout << "\nV = ";
  for (int i = 0; i < 4; ++i){
    std::cout << "[" << i << "] = ";
    std::cin >> V[i];
  }

  //Заполнение матрицы M
  std::cout << "\nM = ";
  for(int i = 0; i < 4; ++i){
    for(int j = 0; j < 4; ++j){
      std::cout << "[" << i << "][" << j <<"] = ";
      std::cin >> M[i][j];
    }
  }

  //Умножение начального вектора на матрицу
  std::cout << "\nR = ";
  for(int i = 0; i < 4; ++i){
    for(int j = 0; j < 4; ++j){
      R[i] += (V[i] * M[j][i]);
    }
    std::cout << R[i] << " ";
  }
}

/*
Задача 6. Умножение матрицы на вектор

Реализуйте частный случай умножения матрицы на матрицу, а именно — умножение вектора на матрицу. Данная операция также весьма распространена в компьютерной индустрии в целом и в компьютерное графике в частности, поэтому это будет хорошим упражнением.

Итак, у нас есть 4-х компонентный вектор V представленный с помощью массива, и матрица M размером 4х4, представленная в виде двумерного массива. Их произведением будет новый 4-х компонентный вектор R. Его компоненты будут суммой произведений компонент вектора V на строку матрицы M. Индекс столбца при этом равен индексу соответствующей компоненты вектора R, который мы и рассчитываем в текущий момент времени.

Все входные данные, матрица M и вектор V вносятся из пользовательского ввода.  Итоговый вектор R надо вывести в консоль (std::cout). Тип данных элементов - всегда float. Желательно реализовать этот алгоритм с помощью вложенного цикла на умножение колонки.
*/